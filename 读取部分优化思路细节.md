我的策略是并行读取，即一个磁头在移动过程中可以读取多个对象的对象块，并尽可能读取需要被读取的对象块。同时也可以由多个磁头协同读取某一个对象的不同对象块。另外，在request中添加phase属性记录该请求已经读取了多少块对象块。

然后外围是以磁头在存储单元上移动为循环。在一时间片最开始的时候，若某一硬盘的磁头正好停在需要被读的对象块上，则直接读；否则Pass；或者Jump

Request结构体增加一个int型变量phase，记录这个请求读取对象的进度，并用来判断是否读取成功；Object结构体增加一个 int* readnum = new int[size]，记录它的每个对象块还要被读的次数。

在某一时间片的一开始，根据磁头是否在某一频繁标签范围内，选择是否Jump。

在某一时间片的一开始，如果不jump，停在需要被读取的对象块的磁头直接读。但这是单纯按磁头编号为顺序的，并没有考虑有的磁盘可能都可以读某一个对象块时，有的磁盘读取消耗的令牌数更少（该磁头连续读取的次数更多）。但这很难解决，除非记录下相关信息。

object结构体的int last_request_point;//最近一次读取请求，初始化为0。这个在后面磁头读取某一对象块后，需要判断是为哪个请求而读。题目虽然允许，在前面的请求还未完成的情况下，先满足后面的请求。但这样太复杂（超过团队的水平），所以我用这个last_request_point去回溯找还未完成的请求中最早的那个请求，选择先满足它。